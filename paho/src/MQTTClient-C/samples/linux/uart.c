#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<termios.h>
#include<errno.h>
#include<string.h>

#include"cJSON.h"

#include "uart.h"


int UART_Open(int fd,char* port)
{

  	fd = open( port, O_RDWR|O_NOCTTY|O_NDELAY);
  	if (FALSE == fd){
		perror("Can't Open Serial Port");
  		return(FALSE);
  	}
  	if(fcntl(fd, F_SETFL, 0) < 0){
		printf("fcntl failed!\n");
    		return(FALSE);
  	} else {
       	//	printf("fcntl=%d\n",fcntl(fd, F_SETFL,0));
  	}
  	if(0 == isatty(STDIN_FILENO)){
  		printf("standard input is not a terminal device\n");
        	return(FALSE);
  	}
  	return fd;
}
void UART_Close(int fd)
{
	close(fd);
}


int UART_Set(int fd,int speed,int flow_ctrl,int databits,int stopbits,int parity)
{

    	int   i;
  //	int   status;
        int   speed_arr[] = {B115200, B38400, B19200, B9600, B4800, B2400, B1200, B300,
          		     B38400, B19200, B9600, B4800, B2400, B1200, B300
			    };
    	int   name_arr[] = {
			   115200,38400,  19200,  9600,  4800,  2400,  1200,  300, 38400,
          		   19200,  9600, 4800, 2400, 1200,  300
			  };
	struct termios options;


	if(tcgetattr( fd,&options)  !=  0){
	   perror("SetupSerial 1");
	   return(FALSE);
    	}
	for(i= 0;i < sizeof(speed_arr) / sizeof(int);i++) {
		if  (speed == name_arr[i]) {
      			cfsetispeed(&options, speed_arr[i]);
      			cfsetospeed(&options, speed_arr[i]);
		}
    	}
	options.c_cflag |= CLOCAL;
	options.c_cflag |= CREAD;
	switch(flow_ctrl){
		case 0 :
			options.c_cflag &= ~CRTSCTS;
			break;
    		case 1 :
    			options.c_cflag |= CRTSCTS;
    			break;
    		case 2 :
    			options.c_cflag |= IXON | IXOFF | IXANY;
    			break;
	}

	options.c_cflag &= ~CSIZE;
	switch (databits){
		case 5 :
    			options.c_cflag |= CS5;
    			break;
    		case 6	:
    			options.c_cflag |= CS6;
    			break;
    		case 7	:
        		options.c_cflag |= CS7;
        		break;
    		case 8:
        		options.c_cflag |= CS8;
        		break;
       		default:
        		fprintf(stderr,"Unsupported data size\n");
        		return (FALSE);
	}
	switch (parity) {
		case 'n':
    		case 'N':
        		options.c_cflag &= ~PARENB;
        		options.c_iflag &= ~INPCK;
        		break;
    		case 'o':
    		case 'O':
        		options.c_cflag |= (PARODD | PARENB);
        		options.c_iflag |= INPCK;
        		break;
    		case 'e':
    		case 'E':
        		options.c_cflag |= PARENB;
        		options.c_cflag &= ~PARODD;
        		options.c_iflag |= INPCK;
        		break;
    		case 's':
    		case 'S':
        		options.c_cflag &= ~PARENB;
        		options.c_cflag &= ~CSTOPB;
        		break;
        	default:
        		fprintf(stderr,"Unsupported parity\n");
        		return (FALSE);
	}
	switch (stopbits){
		case 1:
			options.c_cflag &= ~CSTOPB;
        		break;
    		case 2:
        		options.c_cflag |= CSTOPB;
       			break;
    		default:
         		fprintf(stderr,"Unsupported stop bits\n");
         		return (FALSE);
	}

    	options.c_oflag &= ~OPOST;

	options.c_cc[VTIME] = 1;
	options.c_cc[VMIN] = 1;

	tcflush(fd,TCIFLUSH);

	if(tcsetattr(fd,TCSANOW,&options) != 0){
		perror("com set error!\n");
    		return (FALSE);
	}
	return (TRUE);
}


int UART_Init(int fd, int speed,int flow_ctrlint ,int databits,int stopbits,char parity)
{

	if (FALSE == UART_Set(fd,speed,flow_ctrlint,databits,stopbits,parity)) {
		return FALSE;
    	} else {
   		return  TRUE;
   	}
}




int UART_Recv(int fd, unsigned char *rcv_buf,int data_len)
{
    int len,fs_sel;
    fd_set fs_read;

    struct timeval time;

    FD_ZERO(&fs_read);
    FD_SET(fd,&fs_read);

    time.tv_sec = 10;
    time.tv_usec = 0;

    fs_sel = select(fd+1,&fs_read,NULL,NULL,&time);
    printf("select return is %d\n",fs_sel);
    if(fs_sel){
	    len = read(fd,rcv_buf,data_len);
	    while(len < data_len)
        {
            len += read(fd,rcv_buf+len,data_len-len);
            printf("len is %d\n",len);
        }
        return len;
    	} else {
		return FALSE;
	}
}


int UART_Send(int fd, unsigned char *send_buf,int data_len)
{
    int ret;

    ret = write(fd,send_buf,data_len);
    if (data_len == ret ){
	   return ret;
    } else {
	   tcflush(fd,TCOFLUSH);
	   return FALSE;

    }

}

void UART_JSON(char *rec_data,int len,cJSON *root )
{
	root=cJSON_CreateObject();

    cJSON_AddNumberToObject(root,"Width",800);


}

unsigned short CRC16(unsigned char *puchMsg,unsigned short msgLen)
{

/* CRC 高位字节值表 */
    static unsigned char auchCRCHi[] = {
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
} ;
/* CRC低位字节值表*/
    static char auchCRCLo[] = {
0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
0x43, 0x83, 0x41, 0x81, 0x80, 0x40
} ;

	unsigned char uchCRCHi = 0xFF ; /* 高CRC字节初始化 */
	unsigned char uchCRCLo = 0xFF ; /* 低CRC 字节初始化 */
    unsigned char usDataLen = msgLen - 2;
	unsigned uIndex ; /* CRC循环中的索引 */

    unsigned char checkHi = puchMsg[msgLen-2];
    unsigned char checkLo = puchMsg[msgLen-1];
    int i=0;
	while (usDataLen--) /* 传输消息缓冲区 */
	{
		uIndex = uchCRCHi ^ *puchMsg++ ; /* 计算CRC */
		uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ;
		uchCRCLo = auchCRCLo[uIndex] ;
	}
//  printf("crc check: %x %x \n",uchCRCHi,uchCRCLo);

    if(uchCRCHi == checkHi || uchCRCLo == checkLo)
        return 1;
    else
        return 0;
//	return (uchCRCHi << 8 | uchCRCLo) ;

}

/*


int main(int argc, char **argv)
{
    int fd = FALSE;
    int ret;
    char rcv_buf[512];
    int i;
    if(argc != 2){
	   printf("Usage: %s /dev/ttySn \n",argv[0]);
	   return FALSE;
    }
    fd = UART_Open(fd,argv[1]);
    if(FALSE == fd){
	   printf("open error\n");
	   exit(1);
    }
    ret  = UART_Init(fd,9600,0,8,1,'N');
    if (FALSE == fd){
	   printf("Set Port Error\n");
	   exit(1);
    }
    ret  = UART_Send(fd,"*IDN?\n",6);
    if(FALSE == ret){
	   printf("write error!\n");
	   exit(1);
    }
    printf("command: %s\n","*IDN?");
    memset(rcv_buf,0,sizeof(rcv_buf));
    for(i=0;;i++)
    {
	   ret = UART_Recv(fd, rcv_buf,512);
    	   if( ret > 0){
	   	rcv_buf[ret]='\0';
	   	printf("%s",rcv_buf);
	   } else {
	   printf("cannot receive data1\n");
            break;
	   }
//	 if('\n' == rcv_buf[ret-1])
//		 break;
    }
    UART_Close(fd);
    return 0;
}
*/
